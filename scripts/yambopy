#!/usr/bin/env python
from yambopy import *
import argparse
import sys

class Cmd():
    """
    Define some generic functions for a command
    """
    def info(self):
        """
        display the available commands
        """
        print('yambopy')
        print('Available commands are:\n')
        for cmd,c in self._commands.items():
            print "%15s -> %s"%(cmd, c.__doc__.split('\n')[1])
    
    def run(self,cmds,args):
        """
        generic run command
        cmds is a dictionary that maps the command to the funciton to run
        """
        cmd = args[0]
        if cmd in cmds.keys():
            cmds[cmd](args[1:])

class PlotEm1sCmd(Cmd):
    """
    Plot em1s calculation

        possible arguments are:
        
        Arguments:
        folder   -> Folder containing the ndb.ems1 files
    """
    def __init__(self,args):
        #check for args
        if len(args) < 1:
            print(self.__doc__)
            exit(0)

        #first and second arguments are mandatory
        folder = args[0]
        
        ys = YamboStaticScreeningDB(save=folder)

        #create plot
        ax = plt.gca()

        ys.plot(ax,marker='o')

        #final plot
        plt.show()

class AnalyseGWCmd(Cmd):
    """
    Study the convergence of GW calculations by looking at the change in band-gap value.

    The script reads from <folder> all results from <variable> calculations and display them.

    Use the band and k-point options according to the size of your k-grid
    and the location of the band extrema.

        Mandatory arguments are:
            folder     -> Folder containing SAVE and convergence runs
            variable   -> Variable tested for convergence (e.g. FFTGvecs)

        Optional variables are:
            -bc, --bandc   (int)  -> Lowest conduction band number
            -kc, --kpointc (int)  -> k-point index for conduction band
            -bv, --bandv   (int)  -> Highest valence band number
            -kv, --kpointv (int)  -> k-point index for valence band
            -np, --nopack  (flag) -> Do not call 'pack_files_in_folder'
            -nt, --notext  (flag) -> Do not print a text file
            -nd, --nodraw  (flag) -> Do not draw (plot) the result
    """

    def __init__(self,args):

        #check for args
        if len(args) <= 1:
            print(self.__doc__)
            exit(0)

        #all the other arguments are passed to the merge_qp function

        parser = argparse.ArgumentParser(description='Study GW convergence with regards to the band-gap value.')
        parser.add_argument('folder'            , help='Folder containing SAVE and convergence runs.')
        parser.add_argument('variable'          , help='Variable tested (e.g. FFTGvecs)'             )
        parser.add_argument('-bc','--bandc'     , help='Lowest conduction band number'    , default=53, type=int)
        parser.add_argument('-kc','--kpointc'   , help='K-point index for conduction band', default=19, type=int)
        parser.add_argument('-bv','--bandv'     , help='Highest valence band number'      , default=52, type=int)
        parser.add_argument('-kv','--kpointv'   , help='K-point index for valence band'   , default=1 , type=int)
        parser.add_argument('-np','--no-pack'   , help='Skip the packing of output files'        , dest='pack', action='store_false')
        parser.add_argument('-nt','--no-text'   , help='Skip the writing of the analysis result' , dest='text', action='store_false')
        parser.add_argument('-nd','--no-draw'   , help='Skip the plotting of the analysis result', dest='draw', action='store_false')
        parser.set_defaults(pack=True,text=True,draw=True)
        args = parser.parse_args(args)

        folder = args.folder ; var    = args.variable
        bandc  = args.bandc  ; kpointc= args.kpointc
        bandv  = args.bandv  ; kpointv= args.kpointv
        pack = args.pack ; text = args.text ; draw = args.draw

        #call analyse_gw from recipes.py
        analyse_gw(folder,var,bandc,kpointc,bandv,kpointv,pack,text)

    def info(self):
        """
        display help to use this command
        """
        print self.__doc__

class AnalyseBSECmd(Cmd):
    """
    Using ypp, you can study the convergence of BSE calculations in 2 ways:
      Create a .png of all absorption spectra relevant to the variable you study
      Look at the eigenvalues of the first n "bright" excitons (given a threshold intensity)

    The script reads from <folder> all results from <variable> calculations for processing.
    The resulting pictures and data files are saved in the ./analyse_bse/ folder.

    Mandatory arguments are:
        folder   -> Folder containing SAVE and convergence runs.
        var      -> Variable tested (e.g. FFTGvecs)

    Optional arguments are:
        -ne,--numbexc  (int)   -> Number of excitons to read beyond threshold (default=2)
        -ie,--intexc   (float) -> Minimum intensity for excitons to be considered bright (default=0.05)
        -de,--degenexc (float) -> Energy threshold under which different peaks are merged (eV) (default=0.01)
        -me,--maxexc   (float) -> Energy threshold after which excitons are not read anymore (eV) (default=8.0)
        -np,--nopack   (flag)  -> Skips packing o- files into .json files
        -nt,--notext   (flag)  -> Skips writing the .dat file
        -nd,--nodraw   (flag)  -> Skips drawing (plotting) the abs spectra
    """
    def __init__(self,args):
        #check for args
        if len(args) < 2:
            print(self.__doc__)
            exit(0)

        # Arguments parser
        parser = argparse.ArgumentParser(description='Study convergence on BS calculations using ypp calls.')
        pa = parser.add_argument
        pa('folder'          , help='Folder containing SAVE and convergence runs.' )
        pa('variable'        , help='Variable tested (e.g. FFTGvecs)' )
        pa('-ne','--numbexc' , help='Number of excitons to read beyond threshold'                    , default=2   ,type=int)
        pa('-ie','--intexc'  , help='Minimum intensity for excitons to be considered bright'         , default=0.05,type=float)
        pa('-de','--degenexc', help='Energy threshold under which different peaks are merged (eV)'   , default=0.01,type=float)
        pa('-me','--maxexc'  , help='Energy threshold after which excitons are not read anymore (eV)', default=8.0 ,type=float)
        pa('-np','--nopack'  , help='Skips packing o- files into .json files',  dest='pack', action='store_false')
        pa('-nt','--notext'  , help='Skips writing the .dat file',              dest='text', action='store_false')
        pa('-nd','--nodraw'  , help='Skips drawing (plotting) the abs spectra', dest='draw', action='store_false')
        parser.set_defaults(pack=True,text=True,draw=True)
        args = parser.parse_args(args)

        folder    = args.folder   ;   var = args.variable
        exc_n     = args.numbexc  ;   exc_int   = args.intexc
        exc_degen = args.degenexc ;   exc_max_E = args.maxexc
        pack      = args.pack   ;   text      = args.text
        draw      = args.draw

        # Function call
        analyse_bse(folder,var,exc_n,exc_int,exc_degen,exc_max_E,pack,text,draw)

class TestCmd(Cmd):
    """
    Run yambopy tests
    
        possible arguments are:

        basic -> fast test where input/output is compared with reference files
        full  -> requires yambo and quantum espresso to be installed
    """
    
    def __init__(self,args):
        #check for args
        if len(args) < 1:
            print(self.__doc__)
            exit(0)

        cmds = {'basic':self.basic,
                'full':self.full}
        self.run(cmds,args)

    def basic(self,*args):
        print args
        
    def full(self,*args):
        print args
    

class MergeQPCmd(Cmd):
    """
    Merge QP databases
    
        possible arguments are:

           <QP files>    -> list of QP files produced by yambo
        -o <output file> -> output file where to save the merged db
    """

    def __init__(self,args):
        """ 
        possible arguments are:
        """ 
        #check for args
        if len(args) <= 1:
            print(self.__doc__)
            exit(0)
        
        #all the other arguments are passed to the merge_qp function
        parser = argparse.ArgumentParser(description='Join different NetCDF quasi-particle databases')
        parser.add_argument('files', nargs='+', type=argparse.FileType('r'))
        parser.add_argument('-o','--output',                       help='Output filename', default='ndb_out.QP')
        parser.add_argument('-v','--verbose', action="store_true", help='Verbose mode')
        args = parser.parse_args(args)

        output  = args.output
        files   = args.files
        verbose = args.verbose
        
        #call merge_qp fomr recipes.py
        merge_qp(output,files,verbose)

    def info(self):
        """
        display help to use this command 
        """
        print self.__doc__

class YambopyCmd(Cmd):
    """
    class to implement commands for yambopy.
    each new command to be added should be implemented as a class inheriting from this one
    """
    _commands = {'plotem1s': PlotEm1sCmd,
                 'analysegw': AnalyseGWCmd,
                 'analysebse': AnalyseBSECmd,
                 'mergeqp':    MergeQPCmd,
                 'test':       TestCmd}

    def __init__(self,*args):
        """
        parse the command from the command line and initialize the class responsible
        for handling such command
        """
        
        #check for args
        if len(args) <= 1:
            self.info()
            exit(0)
 
        #start call graph     
        if args[1] in self._commands:
            cmdclass = self._commands[args[1]]
            self.cmd = cmdclass(args[2:]) 
   
#parse options
ycmd = YambopyCmd(*sys.argv)
